#!/usr/bin/env python3

import argparse
import logging
import os
import sys
import vcf
import subprocess
from scipy.optimize import least_squares
import random
import pandas as pd
import math

# ---------------------------------------------------------------------------------------------------------------------
# Functions
# ---------------------------------------------------------------------------------------------------------------------


def parse_arguments():
    description = "Script to simulate binary phenotypes from a single Roary (gene) variant.\n Designed to test the " \
                  "effect of changing odds ratio (effect size). A file with a single sampled causal gene obtained " \
                  "from sample_casual_variants_from_roary.py is needed as input. Input variants need to be formatted " \
                  "as a multi-sample VCF file. \n" \
                  "NOTE: Simulation of quantitative phenotypes or phenotypes caused by multiple genes is not " \
                  "supported, use simulate_phenotype_using_gcta.py script instead.\n"

    parser = argparse.ArgumentParser(description=description)

    group = parser.add_argument_group('I/O arguments')
    group.add_argument(
        "-v", "--input_roary", action="store", dest="input_roary",
        help="input Roary gene_presence_absence.csv file",
        required=True, metavar="INPUT_ROARY"
    )
    group.add_argument(
        "-f", "--input_format", action="store", dest="input_format",
        help="Roary file format: (1) gene_presence_absence.csv or (2) gene_presence_absence.Rtab",
        required=True, metavar="INPUT_FORMAT"
    )
    group.add_argument(
        "-o", "--out_prefix", action="store", dest="out_prefix",
        help="output prefix used to name simulated phenotype output file",
        required=True, metavar="OUTPUT_PREFIX"
    )
    group.add_argument(
        "-c", "--causal-loci", action="store", dest="causal_loci",
        help="Sampled Roary gene used as causal variant, generated by sample_casual_variants_from_roary.py",
        required=True, metavar="CAUSAL_LOCI"
    )
    group.add_argument(
        "-x", "--simu-cc", action="store", dest="simu_cc",
        help="Number of cases and the number of controls, separated by comma (e.g. 100,200)",
        required=True, metavar="SIMU_CC"
    )
    group.add_argument(
        "-r", "--simu-rep", action="store", dest="simu_rep",
        help="Number of simulation repetitions. The default value is 1 if this option is not specified.",
        required=False, metavar="SIMU_REP", default="1"
    )
    group.add_argument(
        "-a", "--allele-frequency", action="store", dest="allele_frequency",
        help="Allele frequency of causal variant. If not specified, observed allele frequency of causal variant will "
             "be used. If specified, it cannot be higher than the observed allele frequency",
        required=False, metavar="ALLELE_FREQ", default="NA"
    )
    group.add_argument(
        "-e", "--effect-size", action="store", dest="effect_size",
        help="Effect size of causal variant in odds ratio units. If specified, this value will be used instead of that "
             "extracted from --causal-loci file",
        required=False, metavar="EFFECT_SIZE", default="NA"
    )
    return parser.parse_args()


def check_positive_integer(value, name, minim, maxim):
    """
    Function to check that a value is a positive integer
    :param value: value of variable to check
    :param name: message about variable to print
    :param minim: minimum value the variable should be within
    :param maxim: maximum value the variable should be within
    :return:
    """
    try:
        val = int(value)
        if val < 0:
            logging.error(f"{name} provided ''{value}'' must be a positive integer")
            sys.exit(-1)
        if minim is not None:
            if val < minim:
                logging.error(f"{name} provided ''{value}'' must be greater than {minim}")
                sys.exit(-1)
        if maxim is not None:
            if val > maxim:
                logging.error(f"{name} provided ''{value}'' must be smaller than {maxim}")
                sys.exit(-1)
    except ValueError:
        logging.error(f"{name} provided '{value}' is not an integer")
        sys.exit(-1)


def check_positive_float(value, name, minim, maxim):
    """
    Function to check that a value is a positive numberical value (float)
    :param value: value of variable to check
    :param name: message about variable to print
    :param minim: minimum value the variable should be within
    :param maxim: maximum value the variable should be within
    :return:
    """
    try:
        val = float(value)
        if val < 0:
            logging.error(f"{name} provided ''{value}'' must be a positive value")
            sys.exit(-1)
        if minim is not None:
            if val < minim:
                logging.error(f"{name} provided ''{value}'' must be greater than {minim}")
                sys.exit(-1)
        if maxim is not None:
            if val > maxim:
                logging.error(f"{name} provided ''{value}'' must be smaller than {maxim}")
                sys.exit(-1)
    except ValueError:
        logging.error(f"{name} provided '{value}' is not a numerical value")
        sys.exit(-1)


def solve_odds_ratio_function(variables, mut, wt, cases, controls, odds_ratio):
    """
    This function is used to calculate the number of cases and controls, with and without the causal variant,
    to achieve the chosen odds ratio, where:
        controls_mut is the number of controls with causal variant
        cases_mut is the number of cases with causal variant
        controls_wt is the number of controls without causal variant
        cases_wt is the number of cases without causal variant
    A system of functions (f1 to f5) need to minimised to zero
    :param variables: initial guess of variables
    :param mut: number of individuals/samples with causal variant
    :param wt: number of individuals/samples without causal variant
    :param cases: number of cases
    :param controls: number of controls
    :param odds_ratio: chosen odds ratio of causal variant
    :return:
    """
    controls_mut = variables[0]
    cases_mut = variables[1]
    cases_wt = variables[2]
    controls_wt = variables[3]
    f1 = controls_mut + cases_mut - mut
    f2 = controls_wt + cases_wt - wt
    f3 = cases_wt + cases_mut - cases
    f4 = controls_wt + controls_mut - controls
    f5 = odds_ratio * (cases_wt/controls_wt) - (cases_mut/controls_mut)
    return [f1, f2, f3, f4, f5]


def solve_odds_ratio_function_2(variables, num_mut, num_wt, allele_frequency, sample_size, odds_ratio):
    """
    Same as above, but where the exact case/control ratio or allele frequency may not be met. This is used in cases
    where the number of mutated or wildtype samples needed to achieve the desired allele frequency exceeds the number
    of mutated or wildtype samples available to sub-sample from.

    A system of functions (f1 to f5) need to minimised to zero, where each function states:
    f1: the number of mutated cases + controls cannot exceed # of samples with variant available to sub-sample from
    f2: the number of WT cases + WT controls cannot exceed the number of WT samples available to sub-sample from
    f3: the chosen/desired overall sample size must be met
    f4: the chosen/desired allele frequency must be met
    f5: the chosen/desired odds ratio must be met

    :param variables: initial guess of variables
    :param num_mut: number of samples with causal variant according to variant file
    :param num_wt: number of samples without causal variant according to variant file
    :param allele_frequency: chosen allele frequency
    :param sample_size: number of cases and controls
    :param odds_ratio: chosen odds ratio of causal variant
    :return:
    """
    controls_mut = variables[0]
    cases_mut = variables[1]
    cases_wt = variables[2]
    controls_wt = variables[3]
    f1 = (controls_mut + cases_mut) - num_mut*allele_frequency
    f2 = (controls_wt + cases_wt) - num_wt*(1-allele_frequency)
    f3 = controls_mut + controls_wt + cases_mut + controls_wt - sample_size
    f4 = float(((controls_mut + cases_mut)/sample_size)) - float(allele_frequency)
    f5 = odds_ratio * (cases_wt/controls_wt) - (cases_mut/controls_mut)
    return [f1, f2, f3, f4, f5]


# ------------------------------------------------------------------------------------
# Main program
# ------------------------------------------------------------------------------------

def _main():
    # Configure logging
    logging.basicConfig(
        format='%(asctime)s %(levelname)s: %(message)s',
        level=logging.INFO
    )
    # Get arguments
    args = parse_arguments()

    # Making sure input files exist
    input_files = [args.input_roary, args.causal_loci]
    for input_file in input_files:
        if not os.path.exists(input_file):
            logging.error(f'Input file {input_file} not found!')
            sys.exit(-1)

    # Making sure input_format is either 1 or 2
    if args.input_format is not '1':
        if args.input_format is not '2':
            logging.error(f'Input format chosen (-f, --input_format) \'{args.input_format}\' must be either 1 or 2.')
            sys.exit(-1)

    # Parsing parameters
    (num_cases, num_controls) = args.simu_cc.split(',')
    num_rep = args.simu_rep

    # Making sure input parameters meet expected values
    int_param = [num_cases, num_controls, num_rep]
    int_param_names = ['number of cases in (--simu-cc)', 'number of controls in (--simu-cc)',
                       'number of simulation repetitions (--simu-rep)']

    for idx, param in enumerate(int_param):
        check_positive_integer(param, int_param_names[idx], None, None)
    sample_size = int(num_cases) + int(num_controls)

    if args.allele_frequency is not 'NA':
        check_positive_float(args.allele_frequency, " allele frequency (--allele-frequency) ", 0, 1)
    if args.effect_size is not 'NA':
        check_positive_float(args.effect_size, " effect size (--effect-size)", 0, None)

    # Reading causal variant file. And making sure only one variant exists.
    logging.info(f"Reading causal variant file {args.causal_loci}...")
    causal_variants = dict()
    odds_ratio = ''
    file = open(args.causal_loci, "r")
    for line in file:
        [var_id, odds_ratio] = line.strip().split('\t')
        check_positive_float(odds_ratio, "odds ratio in " + args.causal_loci, 0, None)
        causal_variants[var_id] = odds_ratio

    # Printing chosen parameters
    print("Chosen parameters: ")
    print("\tCausal variant(s): " + ' '.join(causal_variants))
    print("\tOdds ratio (from causal variant file): " + str(odds_ratio))
    print("\tNumber of cases: " + str(num_cases))
    print("\tNumber of controls: " + str(num_controls))
    print("\tSample size: " + str(sample_size))
    print("\tAllele frequency: " + str(args.allele_frequency))

    # Opening gene_presence_absence.csv file and saving gene frequencies
    logging.info(f"Opening {args.input_roary} file and calculating gene frequency...")
    gene_calls = dict()  # dictionary to save gene presence/absence calls: gene_calls[gene_id] = presabs
    num_genes = 0
    roary_samples = list()
    f = open(args.input_roary, 'r')
    if args.input_format is '1':
        fields = f.readline().strip().split('","')  # sample ids are extracted from first line
        samples = fields[14:len(fields)]
        samples = [s.replace('"', '') for s in samples]
        roary_samples = samples
        for line in f:
            num_genes = num_genes + 1
            fields = line.strip().split('","')
            gene_id = fields[0].replace('"', '')
            presabs = fields[14:len(fields)]
            presabs = [allele.replace('"', '') for allele in presabs]
            gene_calls[gene_id] = presabs
            # print("gene_calls[" + gene_id + "] --> ", gene_calls[gene_id])
    if args.input_format is '2':
        fields = f.readline().strip().split('\t')  # sample ids are extracted from first line
        samples = fields
        samples.pop(0)
        roary_samples = samples
        for line in f:
            num_genes = num_genes + 1
            fields = line.strip().split('\t')
            gene_id = fields[0]
            presabs = fields
            presabs.pop(0)
            gene_calls[gene_id] = presabs
            # print("gene_calls[" + gene_id + "] --> ", gene_calls[gene_id])
    f.close()
    print("\tNumber of genes: ", str(num_genes))
    print("\tNumber of genes saved: ", str(len(gene_calls)))
    print("\tNumber of samples: ", str(len(roary_samples)))
    logging.info(f"Opening gene_presence_absence file and calculating gene frequency. DONE.")

    # Extracting samples with and without causal variant (mutated and wild-type)
    logging.info(f"Extracting samples with and without causal variant(s) (mutated and wild-type)...")
    roary_calls = dict()
    for var_id in causal_variants:
        variant_calls = list()
        if var_id in gene_calls:
            variant_calls = gene_calls[var_id]
        else:
            logging.error(f'Gene {var_id} in {args.causal_loci} not found in {args.input_roary}')
            sys.exit(-1)
        if len(roary_samples) != len(variant_calls):
            logging.error(f'Number of sample ids extracted from Roary {str(len(roary_samples))} does not match number of '
                          f'genotype calls {str(len(variant_calls))} for {var_id}. Check Roary format.')
            sys.exit(-1)
        roary_calls[var_id] = variant_calls
    roary_samples_mut = []  # list to store samples with causal gene (mutated)
    roary_samples_wt = []  # list to store samples without causal gene (wild-type)
    for var_id in causal_variants:
        variant_calls = roary_calls[var_id]
        for idx, sample in enumerate(roary_samples):
            allele = str(variant_calls[idx])
            # if allele is '0':
            #     roary_samples_wt.append(sample)
            if allele is '1':
                roary_samples_mut.append(sample)
    roary_samples_mut = list(set(roary_samples_mut))
    roary_samples_wt = list(set(roary_samples) - set(roary_samples_mut))
    if len(roary_samples_mut) == 0:
        logging.error(f'Number of samples with causal variant is zero. Check VCF format, and allele coding.')
        sys.exit(-1)
    if len(roary_samples_wt) == 0:
        logging.error(f'Number of samples without causal variant is zero. Check VCF format, and allele coding.')
        sys.exit(-1)
    print("\t\tNumber of mutated individuals available to sample from: " + str(len(roary_samples_mut)))
    print("\t\tNumber of wild-type individuals available to sample from: " + str(len(roary_samples_wt)))
    allele_frequency = len(roary_samples_mut)/(len(roary_samples_mut)+len(roary_samples_wt))
    print("\t\tObserved allele frequency: " + str(allele_frequency))

    # Replacing allele frequency and odds ratio if options specified
    if args.allele_frequency is not 'NA':
        if float(args.allele_frequency) > allele_frequency:
            logging.error(f'Chosen allele frequence (--allele-frequency) {args.allele_frequency} cannot be higher than '
                          f'the observed one {allele_frequency}')
            sys.exit(-1)
        allele_frequency = float(args.allele_frequency)
    if args.effect_size is not 'NA':
        odds_ratio = float(args.effect_size)

    # Calculating number of cases and controls, with and without the causal variant, to achieve the chosen odds ratio
    logging.info(f"Calculating number of cases and controls, with and without the causal variant, to achieve the "
                 f"chosen odds ratio...")
    initialGuess = [1, 1, 1, 1]
    mut = allele_frequency * float(sample_size)
    mut = int(math.floor(mut))
    wt = int(sample_size) - mut
    cases = num_cases
    controls = num_controls
    print("\tInput variables:")
    print("\t\tNumber of mutated individuals to sample: " + str(mut))
    print("\t\tNumber of wild-type individuals to sample: " + str(wt))
    print("\t\tNumber of cases to assign: " + str(cases))
    print("\t\tNumber of controls to assign: " + str(controls))
    print("\t\tSample size: " + str(sample_size))
    print("\t\tOdds ratio: " + str(odds_ratio))
    if mut > len(roary_samples_mut) or wt > len(roary_samples_wt):
        result = least_squares(solve_odds_ratio_function_2, initialGuess,
                               args=(len(roary_samples_mut), len(roary_samples_wt), float(args.allele_frequency), int(sample_size), float(odds_ratio)),
                               bounds=(0, int(sample_size)))
    else:
        result = least_squares(solve_odds_ratio_function, initialGuess,
                               args=(int(mut), int(wt), int(cases), int(controls), float(odds_ratio)),
                               bounds=(0, int(sample_size)))
    [controls_mut, cases_mut, cases_wt, controls_wt] = result.x
    # Values are rounded to integers, 0 samples are not allowed.
    # NOT DONE, as it will cause errors when only one mutated sample if found
    controls_mut = int(math.floor(controls_mut))
    cases_mut = int(math.floor(cases_mut))
    cases_wt = int(math.floor(cases_wt))
    controls_wt = int(math.floor(controls_wt))
    print("\tSolved variables:")
    print("\t\tNumber of mutated contols: " + str(round(controls_mut)))
    print("\t\tNumber of mutated cases: " + str(cases_mut))
    print("\t\tNumber of wild-type controls: " + str(controls_wt))
    print("\t\tNumber of wild-type cases: " + str(cases_wt))
    # print("\t\tCalculated odds ratio: " + str(round((cases_mut/controls_mut)/(cases_wt/controls_wt))))

    # Randomly selecting samples across repetitions
    logging.info(f"Randomly selecting samples across repetitions, creating phenotype file...")
    phen = pd.DataFrame({'samples': roary_samples})
    for r in range(1, int(args.simu_rep)+1):
        cases_mut_samples = random.sample(roary_samples_mut, cases_mut)
        controls_mut_samples = random.sample(set(roary_samples_mut) - set(cases_mut_samples), controls_mut)
        cases_wt_samples = random.sample(roary_samples_wt, cases_wt)
        controls_wt_samples = random.sample(set(roary_samples_wt)-set(cases_wt_samples), controls_wt)
        cases_samples = list(cases_mut_samples) + list(cases_wt_samples)
        controls_samples = list(controls_mut_samples) + list(controls_wt_samples)
        print("\t\tNumber of samples selected as mutated contols: " + str(len(controls_mut_samples)))
        print("\t\tNumber of samples selected as mutated cases: " + str(len(cases_mut_samples)))
        print("\t\tNumber of samples selected as wild-type controls: " + str(len(controls_wt_samples)))
        print("\t\tNumber of samples selected as wild-type cases: " + str(len(cases_wt_samples)))
        # Assigning phenotypes to cases and controls
        phenotype = ['NA'] * len(roary_samples)
        for idx, sample in enumerate(roary_samples):
            if sample in cases_samples:
                phenotype[idx] = '1'
            if sample in controls_samples:
                phenotype[idx] = '0'
        # Appending phenotype list to dataframe
        phen['phenotype' + str(r)] = phenotype
    phen.to_csv(args.out_prefix + '.phen', header=True, sep='\t', index=False)
    logging.info(f"Simulated phenotype file saved as {args.out_prefix + '.phen'}")


if __name__ == "__main__":
    _main()






